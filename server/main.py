"""GreenOps Server — Production-ready FastAPI application"""
import logging
import os
import sys
import time
from contextlib import asynccontextmanager

import structlog
from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.gzip import GZipMiddleware
from fastapi.responses import JSONResponse

from config import get_settings
from database import create_tables, engine
from middleware.rate_limiter import RateLimitMiddleware
from middleware.request_id import RequestIDMiddleware
from middleware.security_headers import SecurityHeadersMiddleware
from routers import auth, agents, machines, dashboard

structlog.configure(
    processors=[
        structlog.contextvars.merge_contextvars,
        structlog.processors.add_log_level,
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.StackInfoRenderer(),
        structlog.processors.format_exc_info,
        structlog.processors.JSONRenderer()
        if os.getenv("ENV", "development") == "production"
        else structlog.dev.ConsoleRenderer(),
    ],
    wrapper_class=structlog.make_filtering_bound_logger(logging.INFO),
    context_class=dict,
    logger_factory=structlog.PrintLoggerFactory(),
    cache_logger_on_first_use=True,
)

logger = structlog.get_logger(__name__)


@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    ASGI lifespan handler.

    IMPORTANT — Gunicorn multi-worker note
    ----------------------------------------
    With `--worker-class uvicorn.workers.UvicornWorker` each worker process
    runs this lifespan independently. That means ensure_admin_exists() is
    called once per worker (default: 4 times concurrently).

    ensure_admin_exists() uses a PostgreSQL advisory lock internally to
    guarantee only one worker performs the INSERT. The others detect the
    already-committed row and return immediately. This is safe and correct.

    If INITIAL_ADMIN_PASSWORD is NOT set, a random password is generated by
    whichever worker wins the lock. Look for the log key
    "admin_password_auto_generated" — it will appear exactly once.
    Set INITIAL_ADMIN_PASSWORD in .env to make startup fully deterministic.
    """
    settings = get_settings()
    logger.info("greenops_starting", version="2.0.0", environment=settings.ENV)

    # ── Validate required environment variables ────────────────────────────
    missing = settings.validate()
    if missing:
        logger.error("missing_required_env_vars", missing=missing)
        sys.exit(1)

    # ── Warn loudly if admin password was not pre-configured ──────────────
    if not settings.INITIAL_ADMIN_PASSWORD:
        logger.warning(
            "initial_admin_password_not_set",
            hint=(
                "INITIAL_ADMIN_PASSWORD is empty. A random password will be "
                "generated and logged once at startup. Set this variable in .env "
                "for deterministic, reproducible deployments."
            ),
        )

    # ── Database initialisation ────────────────────────────────────────────
    try:
        await create_tables()
        logger.info("database_initialized")
    except Exception as e:
        logger.error("database_init_failed", error=str(e))
        sys.exit(1)

    # ── Bootstrap admin user (multi-worker-safe via pg_advisory_xact_lock) ─
    from database import AsyncSessionLocal
    from routers.auth import ensure_admin_exists

    try:
        async with AsyncSessionLocal() as db:
            await ensure_admin_exists(db)
    except Exception as e:
        logger.error("admin_bootstrap_failed", error=str(e))
        sys.exit(1)

    logger.info("greenops_ready", host="0.0.0.0", port=8000)

    yield  # ── application runs ──

    logger.info("greenops_shutting_down")
    await engine.dispose()
    logger.info("greenops_stopped")


def create_app() -> FastAPI:
    settings = get_settings()

    app = FastAPI(
        title="GreenOps API",
        description="Green IT Infrastructure Monitoring Platform",
        version="2.0.0",
        # Only expose docs in non-production environments.
        docs_url="/api/docs" if settings.ENV != "production" else None,
        redoc_url="/api/redoc" if settings.ENV != "production" else None,
        openapi_url="/api/openapi.json" if settings.ENV != "production" else None,
        lifespan=lifespan,
    )

    # Middleware is applied in reverse order (last added = first executed).
    app.add_middleware(SecurityHeadersMiddleware)
    app.add_middleware(RequestIDMiddleware)
    app.add_middleware(GZipMiddleware, minimum_size=1000)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=settings.cors_origins_list,
        allow_credentials=True,
        allow_methods=["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
        allow_headers=["Authorization", "Content-Type", "X-Request-ID"],
        expose_headers=["X-Request-ID"],
        max_age=600,
    )
    app.add_middleware(RateLimitMiddleware)

    app.include_router(auth.router,      prefix="/api/auth",      tags=["Authentication"])
    app.include_router(agents.router,    prefix="/api/agents",    tags=["Agents"])
    app.include_router(machines.router,  prefix="/api/machines",  tags=["Machines"])
    app.include_router(dashboard.router, prefix="/api/dashboard", tags=["Dashboard"])

    @app.get("/health", tags=["Health"])
    async def health_check():
        from database import AsyncSessionLocal
        from sqlalchemy import text as sql_text
        try:
            async with AsyncSessionLocal() as db:
                await db.execute(sql_text("SELECT 1"))
            db_status = "healthy"
        except Exception:
            db_status = "unhealthy"

        return {
            "status": "healthy" if db_status == "healthy" else "degraded",
            "version": "2.0.0",
            "database": db_status,
            "timestamp": time.time(),
        }

    @app.exception_handler(404)
    async def not_found_handler(request: Request, exc):
        return JSONResponse(
            status_code=404,
            content={"error": "not_found", "message": "The requested resource was not found."},
        )

    @app.exception_handler(500)
    async def internal_error_handler(request: Request, exc):
        logger.error("unhandled_exception", path=request.url.path, error=str(exc))
        return JSONResponse(
            status_code=500,
            content={
                "error": "internal_server_error",
                "message": "An unexpected error occurred.",
            },
        )

    return app


app = create_app()
